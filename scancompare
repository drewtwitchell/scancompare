#!/usr/bin/env python3
# scancompare version 2.2.8 

import os
import sys
import json
import subprocess
from datetime import datetime, timezone
from urllib.request import Request, urlopen
from pathlib import Path
import webbrowser
import shutil
import tempfile
import html
import base64
import argparse
import re
import time
import random
import uuid

SCRIPT_NAME = "scancompare"
SCRIPT_URL = "https://raw.githubusercontent.com/drewtwitchell/scancompare/main/scancompare"
VERSION = "2.2.8"

args = None  # global placeholder

def get_current_version():
    return VERSION

def check_latest_version(only_check=False):
    already_updated = os.environ.get("SCANCOMPARE_UPDATED") == "1"

    if already_updated and not only_check:
        return

    if not already_updated:
        print("üîé Checking for updates...")

    try:
        # Advanced cache busting: use high-precision timestamp, random nonce, UUID
        timestamp = int(time.time() * 1000)
        nonce = random.randint(100000, 999999)
        uid = uuid.uuid4().hex
        cache_bust_url = f"{SCRIPT_URL}?ts={timestamp}&r={nonce}&uuid={uid}&cb=1"

        req = Request(
            cache_bust_url,
            headers={
                "User-Agent": f"scancompare-updater/{timestamp}-{nonce}-{uid}",
                "Cache-Control": "no-cache",
                "Pragma": "no-cache"
            }
        )

        with urlopen(req) as response:
            new_code = response.read().decode("utf-8")

        latest_match = re.search(r'VERSION\s*=\s*[\'"]([^\'"]+)[\'"]', new_code)
        if not latest_match:
            raise ValueError("Could not determine latest version from script.")

        latest = latest_match.group(1)
        current = get_current_version()

        if latest == current:
            if only_check:
                print(f"üì¶ scancompare version {current}")
                sys.exit(0)
            else:
                print(f"üì¶ Already using latest version ({current})")
                return

        print(f"üîÑ New version detected. Updating scancompare script...")
        update_script(new_code)
        print(f"‚úÖ scancompare updated to version {latest}")
        print("‚ôªÔ∏è Restarting with updated version...")

        os.execve(
            sys.executable,
            [sys.executable, str(get_script_path())] + sys.argv[1:],
            {**os.environ, "SCANCOMPARE_UPDATED": "1"}
        )

    except Exception as e:
        print(f"‚ö†Ô∏è Auto-update check failed: {e}")
        if only_check:
            print(f"üì¶ scancompare version {get_current_version()}")
            sys.exit(0)

def update_script(new_code):
    try:
        script_path = Path(get_script_path())
        if not os.access(script_path, os.W_OK):
            raise PermissionError(f"Cannot write to {script_path}. Try using sudo or adjusting permissions.")

        with tempfile.NamedTemporaryFile("w", delete=False, encoding="utf-8") as tmp:
            tmp.write(new_code)
            temp_path = tmp.name

        os.replace(temp_path, script_path)
    except Exception as e:
        print(f"‚ùå Critical: failed to update script: {e}")
        sys.exit(1)

def get_script_path():
    try:
        return os.path.realpath(__file__)
    except NameError:
        return sys.argv[0]
    
def uninstall_scancompare():
    print("üßπ Uninstalling scancompare...")
    paths_removed = False

    lib_path = Path.home() / ".local" / "lib" / "scancompare" / "scancompare"
    bin_path = Path.home() / ".local" / "bin" / "scancompare"

    for path in [lib_path, bin_path]:
        if path.exists():
            path.unlink()
            print(f"üóëÔ∏è Removed {path}")
            paths_removed = True

    reports_dir = Path("scan_reports")
    if reports_dir.exists():
        shutil.rmtree(reports_dir)
        print("üóëÔ∏è Removed scan_reports directory")

    profile_files = [".zshrc", ".bashrc", ".profile"]
    for profile in profile_files:
        full_path = Path.home() / profile
        if full_path.exists():
            content = full_path.read_text()
            new_content = "\n".join(
                line for line in content.splitlines()
                if 'export PATH="$HOME/.local/bin:$PATH"' not in line
            )
            full_path.write_text(new_content)
            print(f"üßΩ Cleaned PATH entry in {full_path}")

    if paths_removed:
        print("‚úÖ scancompare successfully uninstalled.")
    else:
        print("‚ÑπÔ∏è scancompare was not found or already uninstalled.")
    sys.exit(0)

def handle_cli_args():
    global args
    parser = argparse.ArgumentParser(description="Scan and compare Docker image vulnerabilities")
    parser.add_argument("image", nargs="?", help="Docker image to scan")
    parser.add_argument("--repo-url", help="GitHub repo URL containing Dockerfile for image build")
    parser.add_argument("--version", action="store_true", help="Show scancompare version")
    parser.add_argument("--update", action="store_true", help="Check and apply latest scancompare update")
    parser.add_argument("--uninstall", action="store_true", help="Uninstall scancompare CLI")
    args = parser.parse_args()

    if args.uninstall:
        uninstall_scancompare()

    if args.version:
        print(f"üì¶ scancompare version {get_current_version()}")
        sys.exit(0)

    if args.update:
        check_latest_version(only_check=True)

    return args

def get_version(tool):
    try:
        result = subprocess.run([tool, "version"], capture_output=True, text=True)

        for line in result.stdout.splitlines():
            if tool.lower() == "grype":
                if line.strip().startswith("Version:"):
                    return line.split("Version:")[-1].strip()
            else:
                if tool.lower() in line.lower() or "Version" in line:
                    return line.strip()
    except FileNotFoundError:
        print(f"‚ö†Ô∏è {tool} is not installed or not in PATH.")
        return "not installed"
    except Exception as e:
        print(f"‚ö†Ô∏è Error getting version for {tool}: {e}")
        return "unknown"

    return "unknown"

def run_scan(tool, image, output_path):
    try:
        if tool == "trivy":
            cmd = [tool, "image", "-f", "json", "-o", str(output_path), image]
            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        elif tool == "grype":
            cmd = [tool, image, "-o", "json"]
            with open(output_path, "w") as f:
                subprocess.run(cmd, check=True, stdout=f, stderr=subprocess.DEVNULL)
        return True
    except FileNotFoundError:
        print(f"‚ö†Ô∏è {tool} is not installed or not in PATH.")
        return False
    except subprocess.CalledProcessError as e:
        print(f"‚ö†Ô∏è {tool} scan failed: {e}")
        return False

def extract_cves_with_severity(file_path):
    try:
        with open(file_path) as f:
            data = json.load(f)

        severity_map = {}
        if "Results" in data:  # Trivy format
            for result in data.get("Results", []):
                for vuln in result.get("Vulnerabilities", []):
                    cve = vuln.get("VulnerabilityID")
                    severity = vuln.get("Severity", "UNKNOWN").capitalize()
                    if cve:
                        severity_map[cve] = severity
        elif "matches" in data:  # Grype format
            for match in data.get("matches", []):
                vuln = match.get("vulnerability", {})
                cve = vuln.get("id")
                severity = vuln.get("severity", "UNKNOWN").capitalize()
                if cve:
                    severity_map[cve] = severity

        return severity_map
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to parse {file_path}: {e}")
        return {}


def group_by_severity(cve_map):
    grouped = {}
    for cve, severity in cve_map.items():
        grouped.setdefault(severity, []).append(cve)
    return grouped

def print_cves_by_severity(title, cve_map):
    print(f"üî∏ {title}")
    grouped = group_by_severity(cve_map)
    for severity in sorted(grouped.keys(), key=lambda s: ["Critical", "High", "Medium", "Low", "Unknown"].index(s.capitalize()) if s.capitalize() in ["Critical", "High", "Medium", "Low", "Unknown"] else 99):
        print(f"  {severity} ({len(grouped[severity])}):")
        for cve in sorted(grouped[severity]):
            print(f"    - {cve}")

def display_summary(trivy_cves, grype_cves):
    shared = set(trivy_cves) & set(grype_cves)
    only_trivy = set(trivy_cves) - set(grype_cves)
    only_grype = set(grype_cves) - set(trivy_cves)

    print("\nüìä CLI Summary Report\n")
    print("Tool       | Total | Only in Tool | Shared")
    print("-----------|-------|---------------|--------")
    print(f"Grype      | {len(grype_cves)}   | {len(only_grype)}             | {len(shared)}")
    print(f"Trivy      | {len(trivy_cves)}   | {len(only_trivy)}            | {len(shared)}")

    return shared, only_trivy, only_grype

import html  # make sure this is at the top of your file

def generate_html_report(image, trivy_cves, grype_cves, shared, only_trivy, only_grype, trivy_version, grype_version):
    def format_cves(cve_map):
        grouped = group_by_severity(cve_map)
        sections = ""
        for severity in sorted(
            grouped.keys(),
            key=lambda s: ["Critical", "High", "Medium", "Low", "Unknown"].index(s.capitalize())
            if s.capitalize() in ["Critical", "High", "Medium", "Low", "Unknown"]
            else 99,
        ):
            sections += f"<h4>{severity} ({len(grouped[severity])})</h4><ul>"
            for cve in sorted(grouped[severity]):
                cve_link = f"https://nvd.nist.gov/vuln/detail/{cve}"
                sections += f'<li><a href="{cve_link}" target="_blank">{cve}</a></li>'
            sections += "</ul>"
        return sections or "<p>No CVEs found.</p>"

    timestamp = datetime.now().strftime("%Y-%m-%d")
    report_name = f"scan_report_{image.replace(':', '_')}_{timestamp}.html"
    report_path = Path("scan_reports") / report_name

    # Properly escape raw JSON
    trivy_raw = html.escape(json.dumps(json.load(open("scan_reports/original_trivy.json")), indent=2))
    grype_raw = html.escape(json.dumps(json.load(open("scan_reports/original_grype.json")), indent=2))

    html_report = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>ScanCompare Report</title>
  <style>
    body {{
      font-family: Arial, sans-serif;
      padding: 40px;
      background-color: #f9f9f9;
      color: #333;
    }}
    h1, h2, h3, h4 {{
      color: #222;
    }}
    ul {{
      line-height: 1.6;
    }}
    pre {{
      background: #eee;
      padding: 10px;
      border-left: 4px solid #4CAF50;
      overflow-x: auto;
    }}
    .pdf-button {{
      display: inline-block;
      margin: 30px 0;
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      text-decoration: none;
      border-radius: 5px;
    }}
    table {{
      border-collapse: collapse;
      margin-top: 10px;
    }}
    table td, table th {{
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: center;
    }}
    a {{
      color: #0077cc;
      text-decoration: none;
    }}
    a:hover {{
      text-decoration: underline;
    }}
    .collapsible {{
      background-color: #eee;
      color: #333;
      cursor: pointer;
      padding: 12px;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 15px;
      margin-top: 20px;
    }}
    .active, .collapsible:hover {{
      background-color: #ccc;
    }}
    .content {{
      padding: 0 18px;
      display: none;
      overflow: hidden;
      background-color: #f1f1f1;
      margin-bottom: 20px;
    }}
    .content pre {{
      max-height: 400px;
      overflow: auto;
    }}
  </style>
</head>
<body>
  <h1>Scan Report for {image}</h1>
  <p><strong>Trivy version:</strong> {trivy_version} &nbsp;&nbsp;&nbsp; 
     <strong>Grype version:</strong> {grype_version}</p>

  <table>
    <tr>
      <th>Tool</th>
      <th>Total</th>
      <th>Only in Tool</th>
      <th>Shared</th>
    </tr>
    <tr>
      <td>Grype</td>
      <td>{len(grype_cves)}</td>
      <td><a href="#grype">{len(only_grype)}</a></td>
      <td><a href="#shared">{len(shared)}</a></td>
    </tr>
    <tr>
      <td>Trivy</td>
      <td>{len(trivy_cves)}</td>
      <td><a href="#trivy">{len(only_trivy)}</a></td>
      <td><a href="#shared">{len(shared)}</a></td>
    </tr>
  </table>

  <a class="pdf-button" href="#" onclick="window.print()">üìÑ Export to PDF</a>

  <h2 id="shared">Shared CVEs</h2>
  {format_cves({cve: trivy_cves.get(cve, grype_cves.get(cve, "Unknown")) for cve in shared})}

  <h2 id="trivy">Unique to Trivy</h2>
  {format_cves({cve: trivy_cves[cve] for cve in only_trivy})}

  <h2 id="grype">Unique to Grype</h2>
  {format_cves({cve: grype_cves[cve] for cve in only_grype})}

  <button type="button" class="collapsible">üîç View Raw Trivy JSON</button>
  <div class="content"><pre>{trivy_raw}</pre></div>

  <button type="button" class="collapsible">üîç View Raw Grype JSON</button>
  <div class="content"><pre>{grype_raw}</pre></div>

  <script>
    const coll = document.getElementsByClassName("collapsible");
    for (let i = 0; i < coll.length; i++) {{
      coll[i].addEventListener("click", function() {{
        this.classList.toggle("active");
        const content = this.nextElementSibling;
        if (content.style.display === "block") {{
          content.style.display = "none";
        }} else {{
          content.style.display = "block";
        }}
      }});
    }}
  </script>
</body>
</html>
"""
    report_path.write_text(html_report)
    print(f"‚úÖ HTML report saved: {report_path}")

    open_html = input("üìÅ Open report in browser? (y/n): ").strip().lower()
    if open_html == "y":
        webbrowser.open(f"file://{report_path.absolute()}")

def explain_exit(msg):
    print(f"‚ö†Ô∏è {msg}")
    sys.exit(1)

def validate_image_exists(image):
    try:
        # Try checking locally first
        local_result = subprocess.run(["docker", "image", "inspect", image], capture_output=True)
        if local_result.returncode == 0:
            return True

        # If not found locally, check remote manifest
        remote_result = subprocess.run(["docker", "manifest", "inspect", image], capture_output=True)
        if remote_result.returncode == 0:
            return True

        return False

    except FileNotFoundError:
        print("‚ùå Docker is not installed or not in your PATH.")
        return False
    except Exception as e:
        print(f"‚ö†Ô∏è Unexpected error while validating image: {e}")
        return False

def get_repo_from_url(repo_url):
    match = re.match(r"https?://github.com/([^/]+/[^/]+)(?:\\.git)?", repo_url)
    if match:
        return match.group(1)
    print("‚ùå Invalid GitHub repository URL format.")
    sys.exit(1)

def ensure_gh_installed():
    if shutil.which("gh"):
        return
    print("üîß GitHub CLI (gh) not found. Attempting to install...")
    if shutil.which("brew"):
        subprocess.run(["brew", "install", "gh"], check=True)
    else:
        subprocess.run(["curl", "-fsSL", "https://cli.github.com/install.sh"], check=True)
    print("‚úÖ GitHub CLI installed.")

def ensure_gh_authenticated():
    try:
        # Check if authenticated
        subprocess.run(["gh", "auth", "status"], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

        # Verify GitHub API is accessible
        result = subprocess.run(["gh", "api", "user"], capture_output=True, text=True)
        if result.returncode != 0:
            raise RuntimeError("Could not verify GitHub authentication via user endpoint.")

        # Confirm token has access to GitHub Apps/installations (indirectly validates repo access)
        install_check = subprocess.run(["gh", "api", "user/installations"], capture_output=True, text=True)
        if install_check.returncode != 0:
            print("‚ö†Ô∏è Token may not have access to required installations or private repositories.")
            print("üîÅ You may need to re-authenticate or grant additional permissions.")
            subprocess.run(["gh", "auth", "login"], check=True)

    except subprocess.CalledProcessError:
        print("üîê GitHub authentication required.")
        subprocess.run(["gh", "auth", "login"], check=True)
    except Exception as e:
        print(f"‚ùå Failed to validate GitHub auth: {e}")
        sys.exit(1)

    except subprocess.CalledProcessError:
        print("üîê GitHub authentication required.")
        subprocess.run(["gh", "auth", "login"], check=True)
    except Exception as e:
        print(f"‚ùå Failed to validate GitHub auth: {e}")
        sys.exit(1)

def upload_to_ghas(image, trivy_path, grype_path, shared, only_trivy, only_grype, repo):
    from pathlib import Path
    import json, base64, tempfile, subprocess

    ensure_gh_installed()
    ensure_gh_authenticated()

    def is_valid_sarif(sarif_path):
        try:
            with open(sarif_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                return all(key in data for key in ["version", "runs"])
        except Exception:
            return False

    def upload_sarif(sarif_path, tool_name):
        if not sarif_path.exists() or not is_valid_sarif(sarif_path):
            print(f"‚ö†Ô∏è Skipping {tool_name} SARIF upload: file not found or invalid.")
            return

        commit_sha = subprocess.getoutput("git rev-parse HEAD").strip()
        if "fatal" in commit_sha or not commit_sha:
            commit_sha = "0000000000000000000000000000000000000000"

        ref = subprocess.getoutput("git symbolic-ref -q HEAD || echo refs/heads/main").strip()
        if "fatal" in ref or not ref.startswith("refs/"):
            ref = "refs/heads/main"

        with open(sarif_path, "rb") as f:
            encoded_sarif = base64.b64encode(f.read()).decode("utf-8")

        payload = {
            "commit_sha": commit_sha,
            "ref": ref,
            "sarif": encoded_sarif,
            "tool_name": tool_name,
            "checkout_uri": ".",
            "started_at": datetime.now(timezone.utc).isoformat()
        }

        with tempfile.NamedTemporaryFile(mode="w+", delete=False, suffix=".json") as tmp:
            json.dump(payload, tmp)
            tmp_path = tmp.name

        print(f"üì§ Uploading {tool_name} SARIF to GitHub Advanced Security in {repo}...")
        try:
            subprocess.run([
                "gh", "api", f"repos/{repo}/code-scanning/sarifs",
                "--method", "POST",
                "--input", tmp_path
            ], check=True)
            print(f"‚úÖ Uploaded {tool_name} SARIF to GitHub Advanced Security.")
        except subprocess.CalledProcessError as e:
            print(f"‚ùå GH CLI failed for {tool_name}: {e}")
            if e.stderr:
                print(e.stderr.decode())
        except Exception as e:
            print(f"‚ùå Unexpected error for {tool_name}: {e}")

    scan_dir = Path("scan_reports")
    scan_dir.mkdir(exist_ok=True)

    grype_sarif_path = scan_dir / "ghas_upload_grype.sarif"
    trivy_sarif_path = scan_dir / "ghas_upload_trivy.sarif"
    diff_sarif_path = scan_dir / "ghas_diff.sarif"

    print("üì¶ Generating SARIF files for GHAS upload...")

    try:
        subprocess.run(["grype", image, "-o", "sarif", "--file", str(grype_sarif_path)], check=True)
        upload_sarif(grype_sarif_path, "grype")
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to generate SARIF with grype: {e}")

    try:
        subprocess.run(["trivy", "image", "-f", "sarif", "-o", str(trivy_sarif_path), image], check=True)
        upload_sarif(trivy_sarif_path, "trivy")
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to generate SARIF with trivy: {e}")

    if diff_sarif_path.exists():
        upload_sarif(diff_sarif_path, "scancompare")

def main(args):
    if not args.image and not args.repo_url:
        print("Usage: scancompare <image> [--repo-url <repo>, --version, --update, --uninstall]")
        sys.exit(1)

    check_latest_version()
    scan_dir = Path("scan_reports")
    scan_dir.mkdir(exist_ok=True)

    if args.repo_url:
        temp_dir = tempfile.mkdtemp()
        print(f"üì• Cloning {args.repo_url} into temporary directory...")
        subprocess.run(["git", "clone", args.repo_url, temp_dir], check=True)

        dockerfile_path = None
        for root, _, files in os.walk(temp_dir):
            for file in files:
                if file.lower().startswith("dockerfile"):
                    dockerfile_path = os.path.join(root, file)
                    break
            if dockerfile_path:
                break

        if not dockerfile_path:
            explain_exit("No Dockerfile found in the provided repository.")

        image_tag = f"scancompare-temp-{abs(hash(args.repo_url)) % (10 ** 10)}"
        print(f"üê≥ Building Docker image '{image_tag}' from {dockerfile_path}...")
        try:
            subprocess.run(["docker", "build", "-t", image_tag, os.path.dirname(dockerfile_path)], check=True)
            print(f"‚úÖ Docker image '{image_tag}' built successfully. Starting scans...")
        except subprocess.CalledProcessError:
            explain_exit(f"Docker build failed. Please check the Dockerfile and try building manually with 'docker build -t {image_tag} .' to debug.")

        image = image_tag
        repo = get_repo_from_url(args.repo_url)
    else:
        image = args.image
        repo = None

    if not validate_image_exists(image):
        explain_exit(f"Docker image '{image}' could not be found locally or remotely.")

    trivy_path = scan_dir / "original_trivy.json"
    grype_path = scan_dir / "original_grype.json"

    print(f"\nüîπ Scanning with Trivy...")
    trivy_version = get_version("trivy")
    print(f"   üì¶ Trivy version: {trivy_version}")
    if not run_scan("trivy", image, trivy_path):
        explain_exit("Trivy scan failed or image not found.")
    print(f"    ‚úî Trivy scan saved to {trivy_path}")

    print(f"\nüîπ Scanning with Grype...")
    grype_version = get_version("grype")
    print(f"   üì¶ Grype version: {grype_version}")
    if not run_scan("grype", image, grype_path):
        explain_exit("Grype scan failed or image not found.")
    print(f"    ‚úî Grype scan saved to {grype_path}")

    print(f"üõ†Ô∏è Trivy and Grype scans complete. Preparing upload to GitHub Advanced Security (GHAS)...")

    trivy_data = extract_cves_with_severity(trivy_path)
    grype_data = extract_cves_with_severity(grype_path)

    shared, only_trivy, only_grype = display_summary(trivy_data, grype_data)

    print_cves_by_severity("Unique to Grype", {c: grype_data[c] for c in only_grype})
    print_cves_by_severity("Unique to Trivy", {c: trivy_data[c] for c in only_trivy})
    print_cves_by_severity("Shared CVEs", {c: trivy_data.get(c, grype_data.get(c, "Unknown")) for c in shared})

    if repo:
        upload_to_ghas(image, trivy_path, grype_path, shared, only_trivy, only_grype, repo)
        open_html = input("üìÅ Open HTML report in browser after upload? (y/n): ").strip().lower()
        if open_html == "y":
            generate_html_report(image, trivy_data, grype_data, shared, only_trivy, only_grype, trivy_version, grype_version)
    else:
        generate_html_report(image, trivy_data, grype_data, shared, only_trivy, only_grype, trivy_version, grype_version)

if __name__ == "__main__":
    args = handle_cli_args()
    main(args)

