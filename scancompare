#!/usr/bin/env python3
# scancompare version 2.0.9 

import os
import sys
import json
import subprocess
from datetime import datetime
from urllib.request import urlopen
from pathlib import Path
import webbrowser
import shutil
import tempfile
import html
import base64
import argparse
import re

SCRIPT_NAME = "scancompare"
SCRIPT_URL = "https://raw.githubusercontent.com/drewtwitchell/scancompare/main/scancompare"
VERSION = "2.0.9"

import tempfile

def check_latest_version(only_check=False):
    try:
        response = urlopen(SCRIPT_URL)
        new_code = response.read().decode("utf-8")

        # Extract the latest version
        match = re.search(r'VERSION\s*=\s*[\'"]([^\'"]+)[\'"]', new_code)
        if not match:
            raise ValueError("Could not find VERSION in the downloaded script.")

        latest = match.group(1)

        if latest != VERSION:
            print(f"üîÑ New version available: {VERSION} ‚Üí {latest}")
            update_script(new_code)

            # Re-read the file and double-verify the version
            script_path = Path(get_script_path())
            current_code = script_path.read_text()
            match_post = re.search(r'VERSION\s*=\s*[\'"]([^\'"]+)[\'"]', current_code)
            if not match_post or match_post.group(1) != latest:
                raise RuntimeError(f"Script update failed: expected version {latest}, but got {match_post.group(1) if match_post else 'none'}")

            print("‚úÖ scancompare updated to latest version")
            if only_check:
                sys.exit(0)

            # Relaunch the updated script
            print("‚ôªÔ∏è Restarting with updated version...")
            os.execv(sys.executable, [sys.executable, str(script_path)] + sys.argv[1:])

        elif only_check:
            print(f"üì¶ scancompare version {VERSION}")
            sys.exit(0)

    except Exception as e:
        print(f"‚ö†Ô∏è Auto-update check failed: {e}")
        if only_check:
            print(f"üì¶ scancompare version {VERSION}")
            sys.exit(0)


def update_script(new_code):
    try:
        script_path = Path(get_script_path())
        if not os.access(script_path, os.W_OK):
            raise PermissionError(f"Cannot write to {script_path}. Try using sudo or adjusting permissions.")

        # Write to a temp file first, then atomically replace
        with tempfile.NamedTemporaryFile("w", delete=False, encoding="utf-8") as tmp:
            tmp.write(new_code)
            temp_path = tmp.name

        os.replace(temp_path, script_path)
    except Exception as e:
        print(f"‚ùå Critical: failed to update script: {e}")
        sys.exit(1)


def get_script_path():
    """Handles __file__ resolution even if script is wrapped or symlinked"""
    try:
        return os.path.realpath(__file__)
    except NameError:
        # Fallback if __file__ is not defined
        return sys.argv[0]

def get_version(tool):
    try:
        result = subprocess.run([tool, "version"], capture_output=True, text=True)

        for line in result.stdout.splitlines():
            if tool.lower() == "grype":
                if line.strip().startswith("Version:"):
                    return line.split("Version:")[-1].strip()
            else:
                if tool.lower() in line.lower() or "Version" in line:
                    return line.strip()
    except FileNotFoundError:
        print(f"‚ö†Ô∏è {tool} is not installed or not in PATH.")
        return "not installed"
    except Exception as e:
        print(f"‚ö†Ô∏è Error getting version for {tool}: {e}")
        return "unknown"

    return "unknown"

def run_scan(tool, image, output_path):
    try:
        if tool == "trivy":
            cmd = [tool, "image", "-f", "json", "-o", str(output_path), image]
            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        elif tool == "grype":
            cmd = [tool, image, "-o", "json"]
            with open(output_path, "w") as f:
                subprocess.run(cmd, check=True, stdout=f, stderr=subprocess.DEVNULL)
        return True
    except FileNotFoundError:
        print(f"‚ö†Ô∏è {tool} is not installed or not in PATH.")
        return False
    except subprocess.CalledProcessError as e:
        print(f"‚ö†Ô∏è {tool} scan failed: {e}")
        return False

def extract_cves_with_severity(file_path):
    try:
        with open(file_path) as f:
            data = json.load(f)

        severity_map = {}
        if "Results" in data:  # Trivy format
            for result in data.get("Results", []):
                for vuln in result.get("Vulnerabilities", []):
                    cve = vuln.get("VulnerabilityID")
                    severity = vuln.get("Severity", "UNKNOWN").capitalize()
                    if cve:
                        severity_map[cve] = severity
        elif "matches" in data:  # Grype format
            for match in data.get("matches", []):
                vuln = match.get("vulnerability", {})
                cve = vuln.get("id")
                severity = vuln.get("severity", "UNKNOWN").capitalize()
                if cve:
                    severity_map[cve] = severity

        return severity_map
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to parse {file_path}: {e}")
        return {}


def group_by_severity(cve_map):
    grouped = {}
    for cve, severity in cve_map.items():
        grouped.setdefault(severity, []).append(cve)
    return grouped

def print_cves_by_severity(title, cve_map):
    print(f"üî∏ {title}")
    grouped = group_by_severity(cve_map)
    for severity in sorted(grouped.keys(), key=lambda s: ["Critical", "High", "Medium", "Low", "Unknown"].index(s.capitalize()) if s.capitalize() in ["Critical", "High", "Medium", "Low", "Unknown"] else 99):
        print(f"  {severity} ({len(grouped[severity])}):")
        for cve in sorted(grouped[severity]):
            print(f"    - {cve}")

def display_summary(trivy_cves, grype_cves):
    shared = set(trivy_cves) & set(grype_cves)
    only_trivy = set(trivy_cves) - set(grype_cves)
    only_grype = set(grype_cves) - set(trivy_cves)

    print("\nüìä CLI Summary Report\n")
    print("Tool       | Total | Only in Tool | Shared")
    print("-----------|-------|---------------|--------")
    print(f"Grype      | {len(grype_cves)}   | {len(only_grype)}             | {len(shared)}")
    print(f"Trivy      | {len(trivy_cves)}   | {len(only_trivy)}            | {len(shared)}")

    return shared, only_trivy, only_grype

import html  # make sure this is at the top of your file

def generate_html_report(image, trivy_cves, grype_cves, shared, only_trivy, only_grype, trivy_version, grype_version):
    def format_cves(cve_map):
        grouped = group_by_severity(cve_map)
        sections = ""
        for severity in sorted(
            grouped.keys(),
            key=lambda s: ["Critical", "High", "Medium", "Low", "Unknown"].index(s.capitalize())
            if s.capitalize() in ["Critical", "High", "Medium", "Low", "Unknown"]
            else 99,
        ):
            sections += f"<h4>{severity} ({len(grouped[severity])})</h4><ul>"
            for cve in sorted(grouped[severity]):
                cve_link = f"https://nvd.nist.gov/vuln/detail/{cve}"
                sections += f'<li><a href="{cve_link}" target="_blank">{cve}</a></li>'
            sections += "</ul>"
        return sections or "<p>No CVEs found.</p>"

    timestamp = datetime.now().strftime("%Y-%m-%d")
    report_name = f"scan_report_{image.replace(':', '_')}_{timestamp}.html"
    report_path = Path("scan_reports") / report_name

    # Properly escape raw JSON
    trivy_raw = html.escape(json.dumps(json.load(open("scan_reports/original_trivy.json")), indent=2))
    grype_raw = html.escape(json.dumps(json.load(open("scan_reports/original_grype.json")), indent=2))

    html_report = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>ScanCompare Report</title>
  <style>
    body {{
      font-family: Arial, sans-serif;
      padding: 40px;
      background-color: #f9f9f9;
      color: #333;
    }}
    h1, h2, h3, h4 {{
      color: #222;
    }}
    ul {{
      line-height: 1.6;
    }}
    pre {{
      background: #eee;
      padding: 10px;
      border-left: 4px solid #4CAF50;
      overflow-x: auto;
    }}
    .pdf-button {{
      display: inline-block;
      margin: 30px 0;
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      text-decoration: none;
      border-radius: 5px;
    }}
    table {{
      border-collapse: collapse;
      margin-top: 10px;
    }}
    table td, table th {{
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: center;
    }}
    a {{
      color: #0077cc;
      text-decoration: none;
    }}
    a:hover {{
      text-decoration: underline;
    }}
    .collapsible {{
      background-color: #eee;
      color: #333;
      cursor: pointer;
      padding: 12px;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 15px;
      margin-top: 20px;
    }}
    .active, .collapsible:hover {{
      background-color: #ccc;
    }}
    .content {{
      padding: 0 18px;
      display: none;
      overflow: hidden;
      background-color: #f1f1f1;
      margin-bottom: 20px;
    }}
    .content pre {{
      max-height: 400px;
      overflow: auto;
    }}
  </style>
</head>
<body>
  <h1>Scan Report for {image}</h1>
  <p><strong>Trivy version:</strong> {trivy_version} &nbsp;&nbsp;&nbsp; 
     <strong>Grype version:</strong> {grype_version}</p>

  <table>
    <tr>
      <th>Tool</th>
      <th>Total</th>
      <th>Only in Tool</th>
      <th>Shared</th>
    </tr>
    <tr>
      <td>Grype</td>
      <td>{len(grype_cves)}</td>
      <td><a href="#grype">{len(only_grype)}</a></td>
      <td><a href="#shared">{len(shared)}</a></td>
    </tr>
    <tr>
      <td>Trivy</td>
      <td>{len(trivy_cves)}</td>
      <td><a href="#trivy">{len(only_trivy)}</a></td>
      <td><a href="#shared">{len(shared)}</a></td>
    </tr>
  </table>

  <a class="pdf-button" href="#" onclick="window.print()">üìÑ Export to PDF</a>

  <h2 id="shared">Shared CVEs</h2>
  {format_cves({cve: trivy_cves.get(cve, grype_cves.get(cve, "Unknown")) for cve in shared})}

  <h2 id="trivy">Unique to Trivy</h2>
  {format_cves({cve: trivy_cves[cve] for cve in only_trivy})}

  <h2 id="grype">Unique to Grype</h2>
  {format_cves({cve: grype_cves[cve] for cve in only_grype})}

  <button type="button" class="collapsible">üîç View Raw Trivy JSON</button>
  <div class="content"><pre>{trivy_raw}</pre></div>

  <button type="button" class="collapsible">üîç View Raw Grype JSON</button>
  <div class="content"><pre>{grype_raw}</pre></div>

  <script>
    const coll = document.getElementsByClassName("collapsible");
    for (let i = 0; i < coll.length; i++) {{
      coll[i].addEventListener("click", function() {{
        this.classList.toggle("active");
        const content = this.nextElementSibling;
        if (content.style.display === "block") {{
          content.style.display = "none";
        }} else {{
          content.style.display = "block";
        }}
      }});
    }}
  </script>
</body>
</html>
"""
    report_path.write_text(html_report)
    print(f"‚úÖ HTML report saved: {report_path}")

    open_html = input("üìÅ Open report in browser? (y/n): ").strip().lower()
    if open_html == "y":
        webbrowser.open(f"file://{report_path.absolute()}")

def explain_exit(msg):
    print(f"‚ö†Ô∏è {msg}")
    sys.exit(1)

def validate_image_exists(image):
    try:
        # Try checking locally first
        local_result = subprocess.run(["docker", "image", "inspect", image], capture_output=True)
        if local_result.returncode == 0:
            return True

        # If not found locally, check remote manifest
        remote_result = subprocess.run(["docker", "manifest", "inspect", image], capture_output=True)
        if remote_result.returncode == 0:
            return True

        return False

    except FileNotFoundError:
        print("‚ùå Docker is not installed or not in your PATH.")
        return False
    except Exception as e:
        print(f"‚ö†Ô∏è Unexpected error while validating image: {e}")
        return False

def ensure_gh_installed():
    if shutil.which("gh"):
        return
    print("üîß GitHub CLI (gh) not found. Attempting to install...")
    if shutil.which("brew"):
        subprocess.run(["brew", "install", "gh"], check=True)
    else:
        subprocess.run(["curl", "-fsSL", "https://cli.github.com/install.sh"], check=True)
    print("‚úÖ GitHub CLI installed.")
  

def upload_to_ghas(image, trivy_path, grype_path, shared, only_trivy, only_grype):
    import shutil
    import subprocess
    import json
    import base64
    import datetime
    import tempfile
    from pathlib import Path

    def ensure_gh_installed():
        if shutil.which("gh"):
            return
        print("üîß GitHub CLI (gh) not found. Attempting to install...")
        if shutil.which("brew"):
            subprocess.run(["brew", "install", "gh"], check=True)
        else:
            subprocess.run(["curl", "-fsSL", "https://cli.github.com/install.sh"], check=True)
        print("‚úÖ GitHub CLI installed.")

    def ensure_gh_authenticated():
        try:
            subprocess.run(["gh", "auth", "status"], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except subprocess.CalledProcessError:
            print("üîê GitHub authentication required.")
            subprocess.run(["gh", "auth", "login"], check=True)

    def generate_sarif(tool_name, output_path):
        try:
            subprocess.run([tool_name, image, "-o", "sarif", "--file", str(output_path)], check=True)
            return True
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to generate SARIF with {tool_name}: {e}")
            return False

    def is_valid_sarif(sarif_path):
        try:
            with open(sarif_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                return all(key in data for key in ["version", "runs"])
        except Exception:
            return False

    def upload_sarif(sarif_path, tool_name, repo):
        if not sarif_path.exists() or not is_valid_sarif(sarif_path):
            print(f"‚ö†Ô∏è Skipping {tool_name} SARIF upload: file not found or invalid.")
            return

        commit_sha = subprocess.getoutput("git rev-parse HEAD").strip()
        if "fatal" in commit_sha or not commit_sha:
            commit_sha = "0000000000000000000000000000000000000000"

        ref = subprocess.getoutput("git symbolic-ref -q HEAD || echo refs/heads/main").strip()
        if "fatal" in ref or not ref.startswith("refs/"):
            ref = "refs/heads/main"

        with open(sarif_path, "rb") as f:
            encoded_sarif = base64.b64encode(f.read()).decode("utf-8")

        payload = {
            "commit_sha": commit_sha,
            "ref": ref,
            "sarif": encoded_sarif,
            "tool_name": tool_name,
            "checkout_uri": ".",
            "started_at": datetime.datetime.utcnow().isoformat() + "Z"
        }

        with tempfile.NamedTemporaryFile(mode="w+", delete=False, suffix=".json") as tmp:
            json.dump(payload, tmp)
            tmp_path = tmp.name

        try:
            print(f"üì§ Uploading {tool_name} SARIF to GitHub Advanced Security in {repo}...")
            subprocess.run([
                "gh", "api", f"repos/{repo}/code-scanning/sarifs",
                "--method", "POST",
                "--input", tmp_path
            ], check=True)
            print(f"‚úÖ Uploaded {tool_name} SARIF to GitHub Advanced Security.")
        except subprocess.CalledProcessError as e:
            print(f"‚ùå GH CLI failed for {tool_name}: {e}")
        except Exception as e:
            print(f"‚ùå Unexpected error for {tool_name}: {e}")

    ensure_gh_installed()
    ensure_gh_authenticated()
    repo = choose_or_create_repo()

    scan_dir = Path("scan_reports")
    scan_dir.mkdir(exist_ok=True)

    # Generate Grype SARIF
    grype_sarif_path = scan_dir / "ghas_upload_grype.sarif"
    if not only_trivy:
        generate_sarif("grype", grype_sarif_path)
        upload_sarif(grype_sarif_path, "grype", repo)

    # Generate Trivy SARIF
    trivy_sarif_path = scan_dir / "ghas_upload_trivy.sarif"
    if not only_grype:
        generate_sarif("trivy", trivy_sarif_path)
        upload_sarif(trivy_sarif_path, "trivy", repo)

    # Upload SARIF diff file if it exists
    diff_sarif_path = scan_dir / "ghas_diff.sarif"
    if diff_sarif_path.exists():
        upload_sarif(diff_sarif_path, "scancompare", repo)

def get_repo_from_url(repo_url):
    match = re.match(r"https?://github.com/([^/]+/[^/]+)(?:\.git)?", repo_url)
    if match:
        return match.group(1)
    explain_exit("Invalid GitHub repository URL format.")

def main():
    parser = argparse.ArgumentParser(description="Compare container image scan results between Trivy and Grype.")
    parser.add_argument("image", nargs="?", help="Docker image to scan (e.g., ubuntu:latest)")
    parser.add_argument("--repo-url", help="GitHub repository URL to clone and analyze")
    args = parser.parse_args()

    if not args.image and not args.repo_url:
        print("Usage: scancompare <image> [--repo-url <repo>]")
        sys.exit(1)

    check_latest_version()
    scan_dir = Path("scan_reports")
    scan_dir.mkdir(exist_ok=True)

    if args.repo_url:
        temp_dir = tempfile.mkdtemp()
        print(f"üì• Cloning {args.repo_url} into temporary directory...")
        subprocess.run(["git", "clone", args.repo_url, temp_dir], check=True)

        dockerfile_path = None
        for root, _, files in os.walk(temp_dir):
            for file in files:
                if file.lower().startswith("dockerfile"):
                    dockerfile_path = os.path.join(root, file)
                    break
            if dockerfile_path:
                break

        if not dockerfile_path:
            explain_exit("No Dockerfile found in the provided repository.")

        image_tag = f"scancompare-temp-{int(datetime.now().timestamp())}"
        print(f"üê≥ Building Docker image '{image_tag}' from {dockerfile_path}...")
        try:
            subprocess.run(["docker", "build", "-t", image_tag, os.path.dirname(dockerfile_path)], check=True)
        except subprocess.CalledProcessError:
            explain_exit("Docker build failed. Please check the Dockerfile and try building manually to debug.")

        image = image_tag
        repo = get_repo_from_url(args.repo_url)
    else:
        image = args.image
        repo = None

    if not validate_image_exists(image):
        explain_exit(f"Docker image '{image}' could not be found locally or remotely.")

    trivy_path = scan_dir / "original_trivy.json"
    grype_path = scan_dir / "original_grype.json"

    print(f"\nüîπ Scanning with Trivy...")
    trivy_version = get_version("trivy")
    print(f"   üì¶ Trivy version: {trivy_version}")
    if not run_scan("trivy", image, trivy_path):
        explain_exit("Trivy scan failed or image not found.")
    print(f"    ‚úî Trivy scan saved to {trivy_path}")

    print(f"\nüîπ Scanning with Grype...")
    grype_version = get_version("grype")
    print(f"   üì¶ Grype version: {grype_version}")
    if not run_scan("grype", image, grype_path):
        explain_exit("Grype scan failed or image not found.")
    print(f"    ‚úî Grype scan saved to {grype_path}")

    trivy_data = extract_cves_with_severity(trivy_path)
    grype_data = extract_cves_with_severity(grype_path)

    shared, only_trivy, only_grype = display_summary(trivy_data, grype_data)

    print_cves_by_severity("Unique to Grype", {c: grype_data[c] for c in only_grype})
    print_cves_by_severity("Unique to Trivy", {c: trivy_data[c] for c in only_trivy})
    print_cves_by_severity("Shared CVEs", {c: trivy_data.get(c, grype_data.get(c, "Unknown")) for c in shared})

    if repo:
        upload_to_ghas(image, trivy_path, grype_path, shared, only_trivy, only_grype)
        open_html = input("üìÅ Open HTML report in browser after upload? (y/n): ").strip().lower()
        if open_html == "y":
            generate_html_report(image, trivy_data, grype_data, shared, only_trivy, only_grype, trivy_version, grype_version)
    else:
        generate_html_report(image, trivy_data, grype_data, shared, only_trivy, only_grype, trivy_version, grype_version)

if __name__ == "__main__":
    main()
