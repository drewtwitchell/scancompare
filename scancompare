#!/usr/bin/env python3
# scancompare version 1.8.9

import os
import sys
import json
import subprocess
from datetime import datetime
from urllib.request import urlopen
from pathlib import Path
import webbrowser
import shutil
import tempfile

SCRIPT_NAME = "scancompare"
SCRIPT_URL = "https://raw.githubusercontent.com/drewtwitchell/scancompare/main/scancompare"
VERSION = "1.8.9"

import tempfile

def check_latest_version(only_check=False):
    try:
        response = urlopen(SCRIPT_URL)
        new_code = response.read().decode("utf-8")

        # Extract latest version from downloaded code
        for line in new_code.splitlines():
            if "VERSION =" in line:
                latest = line.split("VERSION =")[1].strip().strip('"').strip("'")
                break
        else:
            raise ValueError("Could not determine latest version from downloaded script")

        if latest != VERSION:
            print(f"üîÑ New version available: {VERSION} ‚Üí {latest}")
            update_script(new_code)

            # Confirm update by reading current file
            current_script = Path(get_script_path()).read_text()
            if f'VERSION = "{latest}"' in current_script or f"VERSION = '{latest}'" in current_script:
                print("‚úÖ scancompare updated to latest version")
                if only_check:
                    sys.exit(0)
                os.execv(sys.executable, [sys.executable] + sys.argv)
            else:
                raise RuntimeError("Script update failed. Version mismatch after update.")
        elif only_check:
            print(f"üì¶ scancompare version {VERSION}")
            sys.exit(0)

    except Exception as e:
        print(f"‚ö†Ô∏è Could not determine remote version or update failed: {e}")
        if only_check:
            print(f"üì¶ scancompare version {VERSION}")
            sys.exit(0)


def update_script(new_code=None):
    try:
        if new_code is None:
            new_code = urlopen(SCRIPT_URL).read().decode("utf-8")

        script_path = Path(get_script_path())

        if not os.access(script_path, os.W_OK):
            raise PermissionError(f"Cannot write to {script_path}. Check permissions.")

        # Write the new version
        script_path.write_text(new_code)

    except Exception as e:
        print("‚ùå Failed to update script:", e)
        sys.exit(1)


def get_script_path():
    """Handles __file__ resolution even if script is wrapped or symlinked"""
    try:
        return os.path.realpath(__file__)
    except NameError:
        # Fallback if __file__ is not defined
        return sys.argv[0]

def get_version(tool):
    try:
        result = subprocess.run([tool, "version"], capture_output=True, text=True)

        for line in result.stdout.splitlines():
            if tool.lower() == "grype":
                if line.strip().startswith("Version:"):
                    return line.split("Version:")[-1].strip()
            else:
                if tool.lower() in line.lower() or "Version" in line:
                    return line.strip()
    except FileNotFoundError:
        print(f"‚ö†Ô∏è {tool} is not installed or not in PATH.")
        return "not installed"
    except Exception as e:
        print(f"‚ö†Ô∏è Error getting version for {tool}: {e}")
        return "unknown"

    return "unknown"

def run_scan(tool, image, output_path):
    try:
        if tool == "trivy":
            cmd = [tool, "image", "-f", "json", "-o", str(output_path), image]
            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        elif tool == "grype":
            cmd = [tool, image, "-o", "json"]
            with open(output_path, "w") as f:
                subprocess.run(cmd, check=True, stdout=f, stderr=subprocess.DEVNULL)
        return True
    except FileNotFoundError:
        print(f"‚ö†Ô∏è {tool} is not installed or not in PATH.")
        return False
    except subprocess.CalledProcessError as e:
        print(f"‚ö†Ô∏è {tool} scan failed: {e}")
        return False

def extract_cves_with_severity(file_path):
    try:
        with open(file_path) as f:
            data = json.load(f)

        severity_map = {}
        if "Results" in data:  # Trivy format
            for result in data.get("Results", []):
                for vuln in result.get("Vulnerabilities", []):
                    cve = vuln.get("VulnerabilityID")
                    severity = vuln.get("Severity", "UNKNOWN").capitalize()
                    if cve:
                        severity_map[cve] = severity
        elif "matches" in data:  # Grype format
            for match in data.get("matches", []):
                vuln = match.get("vulnerability", {})
                cve = vuln.get("id")
                severity = vuln.get("severity", "UNKNOWN").capitalize()
                if cve:
                    severity_map[cve] = severity

        return severity_map
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to parse {file_path}: {e}")
        return {}


def group_by_severity(cve_map):
    grouped = {}
    for cve, severity in cve_map.items():
        grouped.setdefault(severity, []).append(cve)
    return grouped

def print_cves_by_severity(title, cve_map):
    print(f"üî∏ {title}")
    grouped = group_by_severity(cve_map)
    for severity in sorted(grouped.keys(), key=lambda s: ["Critical", "High", "Medium", "Low", "Unknown"].index(s.capitalize()) if s.capitalize() in ["Critical", "High", "Medium", "Low", "Unknown"] else 99):
        print(f"  {severity} ({len(grouped[severity])}):")
        for cve in sorted(grouped[severity]):
            print(f"    - {cve}")

def display_summary(trivy_cves, grype_cves):
    shared = set(trivy_cves) & set(grype_cves)
    only_trivy = set(trivy_cves) - set(grype_cves)
    only_grype = set(grype_cves) - set(trivy_cves)

    print("\nüìä CLI Summary Report\n")
    print("Tool       | Total | Only in Tool | Shared")
    print("-----------|-------|---------------|--------")
    print(f"Grype      | {len(grype_cves)}   | {len(only_grype)}             | {len(shared)}")
    print(f"Trivy      | {len(trivy_cves)}   | {len(only_trivy)}            | {len(shared)}")

    return shared, only_trivy, only_grype

def generate_html_report(image, trivy_cves, grype_cves, shared, only_trivy, only_grype):
    def format_cves(cve_map):
        grouped = group_by_severity(cve_map)
        sections = ""
        for severity in sorted(grouped.keys(), key=lambda s: ["Critical", "High", "Medium", "Low", "Unknown"].index(s.capitalize()) if s.capitalize() in ["Critical", "High", "Medium", "Low", "Unknown"] else 99):
            sections += f"<h4>{severity} ({len(grouped[severity])})</h4><ul>"
            for cve in sorted(grouped[severity]):
                sections += f"<li>{cve}</li>"
            sections += "</ul>"
        return sections or "<p>No CVEs found.</p>"

    timestamp = datetime.now().strftime("%Y-%m-%d")
    report_name = f"scan_report_{image.replace(':', '_')}_{timestamp}.html"
    report_path = Path("scan_reports") / report_name

    html = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>ScanCompare Report</title>
  <style>
    body {{ font-family: Arial, sans-serif; padding: 20px; }}
    h1, h2, h3 {{ color: #333; }}
    ul {{ line-height: 1.6; }}
    pre {{ background: #f4f4f4; padding: 10px; }}
    .pdf-button {{
      display: inline-block; margin: 20px 0; padding: 10px 15px; background: #4CAF50;
      color: white; text-decoration: none; border-radius: 5px;
    }}
  </style>
</head>
<body>
  <h1>Scan Report for {image}</h1>

  <pre>
Tool       | Total | Only in Tool | Shared
-----------|-------|---------------|--------
Grype      | {len(grype_cves)}   | {len(only_grype)}             | {len(shared)}
Trivy      | {len(trivy_cves)}   | {len(only_trivy)}            | {len(shared)}
  </pre>

  <h2>Shared CVEs</h2>
  {format_cves({cve: trivy_cves.get(cve, grype_cves.get(cve, "Unknown")) for cve in shared})}

  <h2>Unique to Trivy</h2>
  {format_cves({cve: trivy_cves[cve] for cve in only_trivy})}

  <h2>Unique to Grype</h2>
  {format_cves({cve: grype_cves[cve] for cve in only_grype})}

  <a class="pdf-button" href="#" onclick="window.print()">üìÑ Export to PDF</a>
</body>
</html>
"""
    report_path.write_text(html)
    print(f"‚úÖ HTML report saved: {report_path}")

    open_html = input("üìÅ Open report in browser? (y/n): ").strip().lower()
    if open_html == "y":
        webbrowser.open(f"file://{report_path.absolute()}")

def explain_exit(msg):
    print(f"‚ö†Ô∏è {msg}")
    sys.exit(1)

def main():
    if len(sys.argv) == 2 and sys.argv[1] in ("--version", "version"):
        print(f"üì¶ scancompare version {VERSION}")
        sys.exit(0)

    if len(sys.argv) == 2 and sys.argv[1] in ("--uninstall", "uninstall"):
        print("üßπ Uninstalling scancompare...")

        paths_removed = False

        # Remove scancompare lib and wrapper
        lib_path = Path.home() / ".local" / "lib" / "scancompare" / "scancompare"
        bin_path = Path.home() / ".local" / "bin" / "scancompare"

        for path in [lib_path, bin_path]:
            if path.exists():
                path.unlink()
                print(f"üóëÔ∏è Removed {path}")
                paths_removed = True

        # Remove scan_reports
        reports_dir = Path("scan_reports")
        if reports_dir.exists():
            shutil.rmtree(reports_dir)
            print("üóëÔ∏è Removed scan_reports directory")

        # Attempt to remove PATH export line
        profile_files = [".zshrc", ".bashrc", ".profile"]
        for profile in profile_files:
            full_path = Path.home() / profile
            if full_path.exists():
                content = full_path.read_text()
                if 'export PATH="$HOME/.local/bin:$PATH"' in content:
                    new_content = "\n".join(
                        line for line in content.splitlines()
                        if 'export PATH="$HOME/.local/bin:$PATH"' not in line
                    )
                    full_path.write_text(new_content)
                    print(f"üßΩ Cleaned PATH entry in {full_path}")

        if paths_removed:
            print("‚úÖ scancompare successfully uninstalled.")
        else:
            print("‚ÑπÔ∏è scancompare was not found or already uninstalled.")
        sys.exit(0)

    if len(sys.argv) < 2:
        print("Usage: scancompare <image>")
        sys.exit(1)

    image = sys.argv[1]
    check_latest_version()

    scan_dir = Path("scan_reports")
    scan_dir.mkdir(exist_ok=True)

    trivy_path = scan_dir / "original_trivy.json"
    grype_path = scan_dir / "original_grype.json"

    print(f"\nüîπ Scanning with Trivy...")
    trivy_version = get_version("trivy")
    print(f"   üì¶ Trivy version: {trivy_version}")
    if not run_scan("trivy", image, trivy_path):
        explain_exit("Trivy scan failed or image not found.")
    print(f"    ‚úî Trivy scan saved to {trivy_path}")

    print(f"\nüîπ Scanning with Grype...")
    grype_version = get_version("grype")
    print(f"   üì¶ Grype version: {grype_version}")
    if not run_scan("grype", image, grype_path):
        explain_exit("Grype scan failed or image not found.")
    print(f"    ‚úî Grype scan saved to {grype_path}")

    trivy_data = extract_cves_with_severity(trivy_path)
    grype_data = extract_cves_with_severity(grype_path)

    shared, only_trivy, only_grype = display_summary(trivy_data, grype_data)

    print_cves_by_severity("Unique to Grype", {c: grype_data[c] for c in only_grype})
    print_cves_by_severity("Unique to Trivy", {c: trivy_data[c] for c in only_trivy})
    print_cves_by_severity("Shared CVEs", {c: trivy_data.get(c, grype_data.get(c, "Unknown")) for c in shared})

    generate_html_report(image, trivy_data, grype_data, shared, only_trivy, only_grype)


if __name__ == "__main__":
    main()
