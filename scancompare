#!/bin/bash
VERSION="1.1.3"
SCRIPT_NAME="scancompare"
SCRIPT_PATH="$HOME/.local/bin/$SCRIPT_NAME"
REPO_USER="drewtwitchell"
REPO_NAME="scancompare"
REMOTE_URL="https://raw.githubusercontent.com/$REPO_USER/$REPO_NAME/main/$SCRIPT_NAME"

if [[ "$1" == "--no-update" ]]; then SKIP_UPDATE=true; shift; else SKIP_UPDATE=false; fi

TARGET="$1"
ORIGINAL_TARGET="$TARGET"
REPORT_DIR="scan_reports"
TIMESTAMP=$(date +"%Y-%m-%d")
HTML_REPORT="$REPORT_DIR/scan_report_${ORIGINAL_TARGET//[\/:]/_}_$TIMESTAMP.html"

ORIG_GRYPE="$REPORT_DIR/original_grype.json"
ORIG_TRIVY="$REPORT_DIR/original_trivy.json"
UPG_GRYPE="$REPORT_DIR/upgraded_grype.json"
UPG_TRIVY="$REPORT_DIR/upgraded_trivy.json"
ORIG_DIFF="$REPORT_DIR/original_diff.json"
UPG_DIFF="$REPORT_DIR/upgraded_diff.json"
UPGRADED_IMAGE=""

step() { echo -e "\nüîπ $1"; }
done_msg() { echo "    ‚úî $1"; }

get_remote_version() {
  curl -fsSL "$REMOTE_URL" | grep 'VERSION=' | cut -d'"' -f2
}

auto_update_check() {
  remote_ver=$(get_remote_version)
  if [[ "$VERSION" != "$remote_ver" ]]; then
    echo "üîÑ New version available: $remote_ver (current: $VERSION)"
    self_update "$@"
  fi
}

self_update() {
  tmp_file=$(mktemp)
  echo "üì• Auto-updating from $REMOTE_URL"
  curl -fsSL "$REMOTE_URL" -o "$tmp_file" || { echo "‚ùå Failed to fetch update."; exit 1; }
  remote_version=$(grep '^VERSION=' "$tmp_file" | cut -d'"' -f2)
  echo "üåê Fetched remote version: $remote_version"
  if [[ "$remote_version" == "$VERSION" ]]; then rm -f "$tmp_file"; return; fi
  chmod +x "$tmp_file"
  mv "$tmp_file" "$SCRIPT_PATH"
  echo "‚úÖ scancompare updated to version $remote_version"
  exec "$SCRIPT_PATH" --no-update "$@"
}

check_tools() {
  for tool in grype trivy jq docker; do
    if ! command -v $tool &>/dev/null; then
      echo "üì¶ Installing $tool..."
      if command -v brew &>/dev/null; then brew install $tool
      else echo "‚ùå Please install $tool manually"; exit 1; fi
    fi
  done
}

clear_old_report() {
  rm -f "$HTML_REPORT"
}

run_scans() {
  local prefix=$1
  mkdir -p "$REPORT_DIR"
  step "Scanning with Trivy..."
  trivy image --format json --output "${prefix}_trivy.json" "$TARGET"
  done_msg "Trivy scan saved to ${prefix}_trivy.json"
  step "Scanning with Grype..."
  grype "$TARGET" -o json > "${prefix}_grype.json"
  done_msg "Grype scan saved to ${prefix}_grype.json"
}

compare_results() {
  local prefix=$1
  local grype_json="${prefix}_grype.json"
  local trivy_json="${prefix}_trivy.json"
  local diff_output="${prefix}_diff.json"
  step "Comparing scan results..."
  grype_cves=$(jq -r '.matches[].vulnerability.id' "$grype_json" | sort | uniq)
  trivy_cves=$(jq -r '[.Results[].Vulnerabilities[]?.VulnerabilityID] | flatten | .[]' "$trivy_json" | sort | uniq)
  echo "$grype_cves" > "$REPORT_DIR/grype.txt"
  echo "$trivy_cves" > "$REPORT_DIR/trivy.txt"
  only_grype=$(comm -23 "$REPORT_DIR/grype.txt" "$REPORT_DIR/trivy.txt")
  only_trivy=$(comm -13 "$REPORT_DIR/grype.txt" "$REPORT_DIR/trivy.txt")
  in_both=$(comm -12 "$REPORT_DIR/grype.txt" "$REPORT_DIR/trivy.txt")
  jq -n \
    --argjson only_in_grype "$(jq -R -s -c 'split("\n") | map(select(. != ""))' <<< "$only_grype")" \
    --argjson only_in_trivy "$(jq -R -s -c 'split("\n") | map(select(. != ""))' <<< "$only_trivy")" \
    --argjson in_both "$(jq -R -s -c 'split("\n") | map(select(. != ""))' <<< "$in_both")" '
    def count(a): a | length;
    {
      summary: {
        total_grype: (count($only_in_grype) + count($in_both)),
        total_trivy: (count($only_in_trivy) + count($in_both)),
        shared: count($in_both),
        only_in_grype: count($only_in_grype),
        only_in_trivy: count($only_in_trivy)
      },
      unique_to_grype: $only_in_grype,
      unique_to_trivy: $only_in_trivy,
      common_vulnerabilities: $in_both,
      actions: {
        suggestion: "Fix shared vulnerabilities and upgrade base image if available."
      }
    }' > "$diff_output"
  done_msg "Diff report saved to $diff_output"
}

generate_html_report() {
  {
    echo "<!DOCTYPE html><html><head><meta charset='UTF-8'><title>Scan Report</title>
    <style>body{font-family:sans-serif;padding:20px;max-width:900px;margin:auto} h1,h2,h3{color:#2c3e50} pre{background:#f4f4f4;padding:10px;border-radius:8px;overflow:auto;} button{margin:10px 0;padding:6px 10px;background:#2c3e50;color:#fff;border:none;border-radius:5px;cursor:pointer} table{border-collapse:collapse;width:100%;margin-top:1em} th,td{border:1px solid #ccc;padding:8px;text-align:left}</style><script>function toggle(id){var el=document.getElementById(id);el.style.display=(el.style.display==='none'||!el.style.display)?'block':'none'} function savePDF(){window.print();}</script></head><body>
    <h1>Scan Summary for <code>$ORIGINAL_TARGET</code></h1>
    <p><strong>Date:</strong> $TIMESTAMP</p>
    <p>This report shows vulnerabilities detected in the image <code>$ORIGINAL_TARGET</code> using Trivy and Grype. It provides shared vulnerabilities, tool-specific issues, and recommendations.</p>
    <button onclick='savePDF()'>üìÑ Download as PDF</button>"
    for type in original upgraded; do
      [[ "$type" == "original" ]] && header="Original Image" || header="Upgraded Image"
      diff_json="$REPORT_DIR/${type}_diff.json"
      [[ -f "$diff_json" ]] || continue
      echo "<h2>$header</h2>"
      jq -r '
        "<table><tr><th>Tool</th><th>Total</th><th>Only in Tool</th><th>Shared</th></tr>" +
        "<tr><td>Grype</td><td>\(.summary.total_grype)</td><td>\(.summary.only_in_grype)</td><td>\(.summary.shared)</td></tr>" +
        "<tr><td>Trivy</td><td>\(.summary.total_trivy)</td><td>\(.summary.only_in_trivy)</td><td>\(.summary.shared)</td></tr></table>" +
        "<h3>Common Vulnerabilities</h3><ul>" + (.common_vulnerabilities | map("<li>" + . + "</li>") | join("")) + "</ul>" +
        "<h3>Suggested Action</h3><p>" + .actions.suggestion + "</p>"
      ' "$diff_json"
      echo "<button onclick=\"toggle('${type}_raw')\">Toggle Raw JSON</button><pre id='${type}_raw' style='display:block;'>"
      jq . "$diff_json"
      echo "</pre>"
    done
    echo "</body></html>"
  } > "$HTML_REPORT"
  echo "‚úÖ HTML report saved: $HTML_REPORT"
}

open_html() {
  echo "üìÑ Opening report..."
  case "$OSTYPE" in
    darwin*) open "$HTML_REPORT" ;;
    linux*) xdg-open "$HTML_REPORT" ;;
    *) echo "View at: $HTML_REPORT" ;;
  esac
}

get_base_image_from_image() {
  docker inspect "$TARGET" 2>/dev/null | jq -r '.[0].Config.Image // empty'
}

check_for_base_image_upgrade() {
  step "Checking for base image upgrade..."
  base_image=$(get_base_image_from_image)
  if [[ -z "$base_image" || "$base_image" == "missing" ]]; then
    echo "‚ö†Ô∏è Could not detect base image."
    echo "üìù Please ensure the image was built with a FROM instruction or contains valid metadata."
    return
  fi
  image_name=$(echo "$base_image" | cut -d':' -f1)
  current_tag=$(echo "$base_image" | cut -d':' -f2)
  tags=$(curl -s "https://registry.hub.docker.com/v1/repositories/$image_name/tags" | jq -r '.[].name')
  latest=$(echo "$tags" | grep -E '^[0-9]+\.[0-9]+' | sort -V | tail -1)
  if [[ "$latest" != "$current_tag" && -n "$latest" ]]; then
    echo "‚¨ÜÔ∏è  Upgrade found: $base_image ‚Üí $image_name:$latest"
    read -p "üîÅ Would you like to scan an upgraded base image? (y/n): " confirm
    [[ "$confirm" != "y" ]] && return
    echo -e "FROM $image_name:$latest\nRUN echo upgrade" > Dockerfile
    build_tag="${TARGET//[:\/]/_}-upgraded"
    docker build -t "$build_tag" . || { echo "‚ùå Build failed"; return; }
    UPGRADED_IMAGE="$build_tag"
    echo "‚úÖ Rebuilt upgraded image: $UPGRADED_IMAGE"
  else
    echo "‚úÖ Base image is up to date."
  fi
}

main() {
  [[ -z "$TARGET" ]] && echo "‚ùå Usage: scancompare <image>" && exit 1
  echo "üîç Starting vulnerability scan for image: $TARGET"
  check_tools
  clear_old_report
  run_scans "$REPORT_DIR/original"
  compare_results "$REPORT_DIR/original"
  generate_html_report
  open_html
  check_for_base_image_upgrade
  if [[ -n "$UPGRADED_IMAGE" ]]; then
    TARGET="$UPGRADED_IMAGE"
    run_scans "$REPORT_DIR/upgraded"
    compare_results "$REPORT_DIR/upgraded"
    generate_html_report
    open_html
  fi
}

[[ "$1" == "update" ]] && self_update "$@" && exit 0
$SKIP_UPDATE || auto_update_check "$@"

main "$@"
