#!/usr/bin/env python3
# scancompare version 1.9.5

import os
import sys
import json
import subprocess
from datetime import datetime
from urllib.request import urlopen
from pathlib import Path
import webbrowser
import shutil
import tempfile
import html

SCRIPT_NAME = "scancompare"
SCRIPT_URL = "https://raw.githubusercontent.com/drewtwitchell/scancompare/main/scancompare"
VERSION = "1.9.5"

import tempfile

def check_latest_version(only_check=False):
    try:
        response = urlopen(SCRIPT_URL)
        new_code = response.read().decode("utf-8")

        # Extract latest version from downloaded code
        latest = None
        for line in new_code.splitlines():
            if line.strip().startswith("VERSION ="):
                latest = line.split("=", 1)[1].strip().strip('"').strip("'")
                break
        if not latest:
            raise ValueError("Could not determine latest version from script.")

        if latest != VERSION:
            print(f"üîÑ New version available: {VERSION} ‚Üí {latest}")
            update_script(new_code)

            # Re-read and confirm
            current_code = Path(get_script_path()).read_text()
            if f'VERSION = "{latest}"' in current_code or f"VERSION = '{latest}'" in current_code:
                print("‚úÖ scancompare updated to latest version")
                if only_check:
                    sys.exit(0)
                os.execv(sys.executable, [sys.executable] + sys.argv)
            else:
                raise RuntimeError("Script update failed. Version mismatch after update.")
        elif only_check:
            print(f"üì¶ scancompare version {VERSION}")
            sys.exit(0)

    except Exception as e:
        print(f"‚ö†Ô∏è Could not determine remote version or update failed: {e}")
        if only_check:
            print(f"üì¶ scancompare version {VERSION}")
            sys.exit(0)


def update_script(new_code=None):
    try:
        if new_code is None:
            new_code = urlopen(SCRIPT_URL).read().decode("utf-8")

        script_path = Path(get_script_path())
        if not os.access(script_path, os.W_OK):
            raise PermissionError(f"Cannot write to {script_path}. Check permissions.")

        # Replace script contents safely
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(new_code)

    except Exception as e:
        print("‚ùå Failed to update script:", e)
        sys.exit(1)


def get_script_path():
    """Handles __file__ resolution even if script is wrapped or symlinked"""
    try:
        return os.path.realpath(__file__)
    except NameError:
        # Fallback if __file__ is not defined
        return sys.argv[0]

def get_version(tool):
    try:
        result = subprocess.run([tool, "version"], capture_output=True, text=True)

        for line in result.stdout.splitlines():
            if tool.lower() == "grype":
                if line.strip().startswith("Version:"):
                    return line.split("Version:")[-1].strip()
            else:
                if tool.lower() in line.lower() or "Version" in line:
                    return line.strip()
    except FileNotFoundError:
        print(f"‚ö†Ô∏è {tool} is not installed or not in PATH.")
        return "not installed"
    except Exception as e:
        print(f"‚ö†Ô∏è Error getting version for {tool}: {e}")
        return "unknown"

    return "unknown"

def run_scan(tool, image, output_path):
    try:
        if tool == "trivy":
            cmd = [tool, "image", "-f", "json", "-o", str(output_path), image]
            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        elif tool == "grype":
            cmd = [tool, image, "-o", "json"]
            with open(output_path, "w") as f:
                subprocess.run(cmd, check=True, stdout=f, stderr=subprocess.DEVNULL)
        return True
    except FileNotFoundError:
        print(f"‚ö†Ô∏è {tool} is not installed or not in PATH.")
        return False
    except subprocess.CalledProcessError as e:
        print(f"‚ö†Ô∏è {tool} scan failed: {e}")
        return False

def extract_cves_with_severity(file_path):
    try:
        with open(file_path) as f:
            data = json.load(f)

        severity_map = {}
        if "Results" in data:  # Trivy format
            for result in data.get("Results", []):
                for vuln in result.get("Vulnerabilities", []):
                    cve = vuln.get("VulnerabilityID")
                    severity = vuln.get("Severity", "UNKNOWN").capitalize()
                    if cve:
                        severity_map[cve] = severity
        elif "matches" in data:  # Grype format
            for match in data.get("matches", []):
                vuln = match.get("vulnerability", {})
                cve = vuln.get("id")
                severity = vuln.get("severity", "UNKNOWN").capitalize()
                if cve:
                    severity_map[cve] = severity

        return severity_map
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to parse {file_path}: {e}")
        return {}


def group_by_severity(cve_map):
    grouped = {}
    for cve, severity in cve_map.items():
        grouped.setdefault(severity, []).append(cve)
    return grouped

def print_cves_by_severity(title, cve_map):
    print(f"üî∏ {title}")
    grouped = group_by_severity(cve_map)
    for severity in sorted(grouped.keys(), key=lambda s: ["Critical", "High", "Medium", "Low", "Unknown"].index(s.capitalize()) if s.capitalize() in ["Critical", "High", "Medium", "Low", "Unknown"] else 99):
        print(f"  {severity} ({len(grouped[severity])}):")
        for cve in sorted(grouped[severity]):
            print(f"    - {cve}")

def display_summary(trivy_cves, grype_cves):
    shared = set(trivy_cves) & set(grype_cves)
    only_trivy = set(trivy_cves) - set(grype_cves)
    only_grype = set(grype_cves) - set(trivy_cves)

    print("\nüìä CLI Summary Report\n")
    print("Tool       | Total | Only in Tool | Shared")
    print("-----------|-------|---------------|--------")
    print(f"Grype      | {len(grype_cves)}   | {len(only_grype)}             | {len(shared)}")
    print(f"Trivy      | {len(trivy_cves)}   | {len(only_trivy)}            | {len(shared)}")

    return shared, only_trivy, only_grype

import html  # make sure this is at the top of your file

def generate_html_report(image, trivy_cves, grype_cves, shared, only_trivy, only_grype, trivy_version, grype_version):
    def format_cves(cve_map):
        grouped = group_by_severity(cve_map)
        sections = ""
        for severity in sorted(
            grouped.keys(),
            key=lambda s: ["Critical", "High", "Medium", "Low", "Unknown"].index(s.capitalize())
            if s.capitalize() in ["Critical", "High", "Medium", "Low", "Unknown"]
            else 99,
        ):
            sections += f"<h4>{severity} ({len(grouped[severity])})</h4><ul>"
            for cve in sorted(grouped[severity]):
                cve_link = f"https://nvd.nist.gov/vuln/detail/{cve}"
                sections += f'<li><a href="{cve_link}" target="_blank">{cve}</a></li>'
            sections += "</ul>"
        return sections or "<p>No CVEs found.</p>"

    timestamp = datetime.now().strftime("%Y-%m-%d")
    report_name = f"scan_report_{image.replace(':', '_')}_{timestamp}.html"
    report_path = Path("scan_reports") / report_name

    # Properly escape raw JSON
    trivy_raw = html.escape(json.dumps(json.load(open("scan_reports/original_trivy.json")), indent=2))
    grype_raw = html.escape(json.dumps(json.load(open("scan_reports/original_grype.json")), indent=2))

    html_report = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>ScanCompare Report</title>
  <style>
    body {{
      font-family: Arial, sans-serif;
      padding: 40px;
      background-color: #f9f9f9;
      color: #333;
    }}
    h1, h2, h3, h4 {{
      color: #222;
    }}
    ul {{
      line-height: 1.6;
    }}
    pre {{
      background: #eee;
      padding: 10px;
      border-left: 4px solid #4CAF50;
      overflow-x: auto;
    }}
    .pdf-button {{
      display: inline-block;
      margin: 30px 0;
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      text-decoration: none;
      border-radius: 5px;
    }}
    table {{
      border-collapse: collapse;
      margin-top: 10px;
    }}
    table td, table th {{
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: center;
    }}
    a {{
      color: #0077cc;
      text-decoration: none;
    }}
    a:hover {{
      text-decoration: underline;
    }}
    .collapsible {{
      background-color: #eee;
      color: #333;
      cursor: pointer;
      padding: 12px;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 15px;
      margin-top: 20px;
    }}
    .active, .collapsible:hover {{
      background-color: #ccc;
    }}
    .content {{
      padding: 0 18px;
      display: none;
      overflow: hidden;
      background-color: #f1f1f1;
      margin-bottom: 20px;
    }}
    .content pre {{
      max-height: 400px;
      overflow: auto;
    }}
  </style>
</head>
<body>
  <h1>Scan Report for {image}</h1>
  <p><strong>Trivy version:</strong> {trivy_version} &nbsp;&nbsp;&nbsp; 
     <strong>Grype version:</strong> {grype_version}</p>

  <table>
    <tr>
      <th>Tool</th>
      <th>Total</th>
      <th>Only in Tool</th>
      <th>Shared</th>
    </tr>
    <tr>
      <td>Grype</td>
      <td>{len(grype_cves)}</td>
      <td><a href="#grype">{len(only_grype)}</a></td>
      <td><a href="#shared">{len(shared)}</a></td>
    </tr>
    <tr>
      <td>Trivy</td>
      <td>{len(trivy_cves)}</td>
      <td><a href="#trivy">{len(only_trivy)}</a></td>
      <td><a href="#shared">{len(shared)}</a></td>
    </tr>
  </table>

  <a class="pdf-button" href="#" onclick="window.print()">üìÑ Export to PDF</a>

  <h2 id="shared">Shared CVEs</h2>
  {format_cves({cve: trivy_cves.get(cve, grype_cves.get(cve, "Unknown")) for cve in shared})}

  <h2 id="trivy">Unique to Trivy</h2>
  {format_cves({cve: trivy_cves[cve] for cve in only_trivy})}

  <h2 id="grype">Unique to Grype</h2>
  {format_cves({cve: grype_cves[cve] for cve in only_grype})}

  <button type="button" class="collapsible">üîç View Raw Trivy JSON</button>
  <div class="content"><pre>{trivy_raw}</pre></div>

  <button type="button" class="collapsible">üîç View Raw Grype JSON</button>
  <div class="content"><pre>{grype_raw}</pre></div>

  <script>
    const coll = document.getElementsByClassName("collapsible");
    for (let i = 0; i < coll.length; i++) {{
      coll[i].addEventListener("click", function() {{
        this.classList.toggle("active");
        const content = this.nextElementSibling;
        if (content.style.display === "block") {{
          content.style.display = "none";
        }} else {{
          content.style.display = "block";
        }}
      }});
    }}
  </script>
</body>
</html>
"""
    report_path.write_text(html_report)
    print(f"‚úÖ HTML report saved: {report_path}")

    open_html = input("üìÅ Open report in browser? (y/n): ").strip().lower()
    if open_html == "y":
        webbrowser.open(f"file://{report_path.absolute()}")

def explain_exit(msg):
    print(f"‚ö†Ô∏è {msg}")
    sys.exit(1)

def validate_image_exists(image):
    try:
        # Try checking locally first
        local_result = subprocess.run(["docker", "image", "inspect", image], capture_output=True)
        if local_result.returncode == 0:
            return True

        # If not found locally, check remote manifest
        remote_result = subprocess.run(["docker", "manifest", "inspect", image], capture_output=True)
        if remote_result.returncode == 0:
            return True

        return False

    except FileNotFoundError:
        print("‚ùå Docker is not installed or not in your PATH.")
        return False
    except Exception as e:
        print(f"‚ö†Ô∏è Unexpected error while validating image: {e}")
        return False

def main():
    if len(sys.argv) == 2 and sys.argv[1] in ("--version", "version"):
        print(f"üì¶ scancompare version {VERSION}")
        sys.exit(0)

    if len(sys.argv) == 2 and sys.argv[1] in ("--uninstall", "uninstall"):
        print("üßπ Uninstalling scancompare...")

        paths_removed = False

        # Remove scancompare lib and wrapper
        lib_path = Path.home() / ".local" / "lib" / "scancompare" / "scancompare"
        bin_path = Path.home() / ".local" / "bin" / "scancompare"

        for path in [lib_path, bin_path]:
            if path.exists():
                path.unlink()
                print(f"üóëÔ∏è Removed {path}")
                paths_removed = True

        # Remove scan_reports
        reports_dir = Path("scan_reports")
        if reports_dir.exists():
            shutil.rmtree(reports_dir)
            print("üóëÔ∏è Removed scan_reports directory")

        # Attempt to remove PATH export line
        profile_files = [".zshrc", ".bashrc", ".profile"]
        for profile in profile_files:
            full_path = Path.home() / profile
            if full_path.exists():
                content = full_path.read_text()
                if 'export PATH="$HOME/.local/bin:$PATH"' in content:
                    new_content = "\n".join(
                        line for line in content.splitlines()
                        if 'export PATH="$HOME/.local/bin:$PATH"' not in line
                    )
                    full_path.write_text(new_content)
                    print(f"üßΩ Cleaned PATH entry in {full_path}")

        if paths_removed:
            print("‚úÖ scancompare successfully uninstalled.")
        else:
            print("‚ÑπÔ∏è scancompare was not found or already uninstalled.")
        sys.exit(0)

    if len(sys.argv) < 2:
        print("Usage: scancompare <image>")
        sys.exit(1)

    image = sys.argv[1]
    check_latest_version()

    if not validate_image_exists(image):
        explain_exit(f"Docker image '{image}' could not be found locally or remotely.")


    scan_dir = Path("scan_reports")
    scan_dir.mkdir(exist_ok=True)

    trivy_path = scan_dir / "original_trivy.json"
    grype_path = scan_dir / "original_grype.json"

    print(f"\nüîπ Scanning with Trivy...")
    trivy_version = get_version("trivy")
    print(f"   üì¶ Trivy version: {trivy_version}")
    if not run_scan("trivy", image, trivy_path):
        explain_exit("Trivy scan failed or image not found.")
    print(f"    ‚úî Trivy scan saved to {trivy_path}")

    print(f"\nüîπ Scanning with Grype...")
    grype_version = get_version("grype")
    print(f"   üì¶ Grype version: {grype_version}")
    if not run_scan("grype", image, grype_path):
        explain_exit("Grype scan failed or image not found.")
    print(f"    ‚úî Grype scan saved to {grype_path}")

    trivy_data = extract_cves_with_severity(trivy_path)
    grype_data = extract_cves_with_severity(grype_path)

    shared, only_trivy, only_grype = display_summary(trivy_data, grype_data)

    print_cves_by_severity("Unique to Grype", {c: grype_data[c] for c in only_grype})
    print_cves_by_severity("Unique to Trivy", {c: trivy_data[c] for c in only_trivy})
    print_cves_by_severity("Shared CVEs", {c: trivy_data.get(c, grype_data.get(c, "Unknown")) for c in shared})

    generate_html_report(image, trivy_data, grype_data, shared, only_trivy, only_grype, trivy_version, grype_version)


if __name__ == "__main__":
    main()
